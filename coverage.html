
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>router: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/kashari/heimdall/router/router.go (83.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// package router

// import (
//         "context"
//         "encoding/json"
//         "net/http"
//         "strings"
//         "sync"
//         "time"

//         "github.com/armon/go-radix"
//         "go.uber.org/zap"
// )

// // Middleware defines a function to wrap a handler.
// type Middleware func(http.HandlerFunc) http.HandlerFunc
// type contextKey string

// // route represents a registered route.
// type route struct {
//         method  string
//         pattern string // e.g. "/users/:id"
//         handler http.HandlerFunc
// }

// // HeimdallRouter is our high-performance HTTP router.
// type HeimdallRouter struct {
//         staticRoutes  *radix.Tree  // static routes stored by exact path
//         dynamicRoutes []route      // routes with parameters (e.g. ":id")
//         middlewares   []Middleware // chain of middlewares
//         logger        *zap.Logger  // zap logger for high-performance logging

//         // Optional enhancements:
//         workerPool  *WorkerPool  // concurrent worker pool for request processing
//         rateLimiter *RateLimiter // simple rate limiter for the critical path
// }

// // NewHeimdall initializes a new router.
// func NewHeimdall() *HeimdallRouter {
//         logger, err := zap.NewProduction()
//         if err != nil {
//                 panic(err)
//         }
//         return &amp;HeimdallRouter{
//                 staticRoutes:  radix.New(),
//                 dynamicRoutes: make([]route, 0),
//                 middlewares:   []Middleware{},
//                 logger:        logger,
//         }
// }

// // Use adds a middleware to the chain.
// func (h *HeimdallRouter) Use(m Middleware) *HeimdallRouter {
//         h.middlewares = append(h.middlewares, m)
//         return h
// }

// // WithWorkerPool configures a worker pool.
// func (h *HeimdallRouter) WithWorkerPool(size int) *HeimdallRouter {
//         h.workerPool = NewWorkerPool(size)
//         return h
// }

// // WithRateLimiter configures a simple rate limiter.
// func (h *HeimdallRouter) WithRateLimiter(maxTokens int, refillInterval time.Duration) *HeimdallRouter {
//         h.rateLimiter = NewRateLimiter(maxTokens, refillInterval)
//         return h
// }

// // Handle registers a route. If the pattern is static (no ":" or "*"),
// // it is stored in the radix tree; otherwise, it goes into dynamicRoutes.
// func (h *HeimdallRouter) Handle(method, pattern string, handler http.HandlerFunc) *HeimdallRouter {
//         r := route{
//                 method:  method,
//                 pattern: pattern,
//                 handler: handler,
//         }
//         if !strings.ContainsAny(pattern, ":*") {
//                 h.staticRoutes.Insert(pattern, r)
//         } else {
//                 h.dynamicRoutes = append(h.dynamicRoutes, r)
//         }
//         return h
// }

// // Named method shortcuts:
// func (h *HeimdallRouter) GET(pattern string, handler http.HandlerFunc) *HeimdallRouter {
//         return h.Handle("GET", pattern, handler)
// }
// func (h *HeimdallRouter) POST(pattern string, handler http.HandlerFunc) *HeimdallRouter {
//         return h.Handle("POST", pattern, handler)
// }
// func (h *HeimdallRouter) DELETE(pattern string, handler http.HandlerFunc) *HeimdallRouter {
//         return h.Handle("DELETE", pattern, handler)
// }
// func (h *HeimdallRouter) PUT(pattern string, handler http.HandlerFunc) *HeimdallRouter {
//         return h.Handle("PUT", pattern, handler)
// }

// // Implements http.Handler. It tries a static lookup first,
// // then falls back on iterating over dynamic routes (extracting parameters).
// func (h *HeimdallRouter) ServeHTTP(w http.ResponseWriter, r *http.Request) {
//         start := time.Now()
//         h.logger.Info("Incoming request",
//                 zap.String("method", r.Method),
//                 zap.String("url", r.URL.Path))

//         // Try static (exact) routes.
//         if val, found := h.staticRoutes.Get(r.URL.Path); found {
//                 rt := val.(route)
//                 if rt.method == r.Method {
//                         h.executeHandler(w, r, rt.handler)
//                         h.logger.Info("Served static route", zap.Duration("duration", time.Since(start)))
//                         return
//                 }
//                 w.Header().Set("Allow", rt.method)
//                 http.Error(w, "405 method not allowed", http.StatusMethodNotAllowed)
//                 h.logger.Info("Method not allowed (static)", zap.Duration("duration", time.Since(start)))
//                 return
//         }

//         // Check dynamic routes.
//         for _, rt := range h.dynamicRoutes {
//                 if params, ok := matchPattern(rt.pattern, r.URL.Path); ok &amp;&amp; rt.method == r.Method {
//                         ctx := context.WithValue(r.Context(), contextKey("params"), params)
//                         h.executeHandler(w, r.WithContext(ctx), rt.handler)
//                         h.logger.Info("Served dynamic route", zap.Duration("duration", time.Since(start)))
//                         return
//                 }
//         }

//         http.NotFound(w, r)
//         h.logger.Info("Route not found", zap.Duration("duration", time.Since(start)))
// }

// // executeHandler applies middleware, then (optionally) uses rate limiting and worker pooling.
// func (h *HeimdallRouter) executeHandler(w http.ResponseWriter, r *http.Request, handler http.HandlerFunc) {
//         // Build the middleware chain.
//         final := handler
//         for i := len(h.middlewares) - 1; i &gt;= 0; i-- {
//                 final = h.middlewares[i](final)
//         }

//         // Rate limiting: if enabled and not allowed, return 429.
//         if h.rateLimiter != nil &amp;&amp; !h.rateLimiter.Allow() {
//                 http.Error(w, "429 Too Many Requests", http.StatusTooManyRequests)
//                 return
//         }

//         // Use worker pool if configured.
//         if h.workerPool != nil {
//                 h.workerPool.Submit(func() {
//                         final(w, r)
//                 })
//         } else {
//                 final(w, r)
//         }
// }

// // Gjallarhorn starts the HTTP server on the given port with keep-alive settings.
// func (h *HeimdallRouter) Gjallarhorn(port string) error {
//         server := &amp;http.Server{
//                 Addr:         ":" + port,
//                 Handler:      h,
//                 IdleTimeout:  90 * time.Second,
//                 ReadTimeout:  10 * time.Second,
//                 WriteTimeout: 10 * time.Second,
//         }
//         h.logger.Info("Starting Heimdall on port " + port)
//         return server.ListenAndServe()
// }

// // matchPattern compares a route pattern like "/user/:id" with a request path.
// // It returns a map of parameters (if any) and true on a match.
// func matchPattern(pattern, path string) (map[string]string, bool) {
//         pParts := splitPath(pattern)
//         rParts := splitPath(path)
//         if len(pParts) != len(rParts) {
//                 return nil, false
//         }
//         params := make(map[string]string)
//         for i := 0; i &lt; len(pParts); i++ {
//                 pp := pParts[i]
//                 rp := rParts[i]
//                 if len(pp) &gt; 0 &amp;&amp; pp[0] == ':' {
//                         key := pp[1:]
//                         params[key] = rp
//                 } else if pp != rp {
//                         return nil, false
//                 }
//         }
//         return params, true
// }

// // Splits a URL path by '/' while ignoring empty segments.
// func splitPath(path string) []string {
//         return strings.FieldsFunc(path, func(r rune) bool { return r == '/' })
// }

// type WorkerPool struct {
//         tasks chan func()
// }

// func NewWorkerPool(size int) *WorkerPool {
//         wp := &amp;WorkerPool{
//                 tasks: make(chan func(), size),
//         }
//         for i := 0; i &lt; size; i++ {
//                 go func() {
//                         for task := range wp.tasks {
//                                 task()
//                         }
//                 }()
//         }
//         return wp
// }

// func (wp *WorkerPool) Submit(task func()) {
//         wp.tasks &lt;- task
// }

// type RateLimiter struct {
//         tokens         int
//         maxTokens      int
//         mu             sync.Mutex
//         refillInterval time.Duration
// }

// func NewRateLimiter(maxTokens int, refillInterval time.Duration) *RateLimiter {
//         rl := &amp;RateLimiter{
//                 tokens:         maxTokens,
//                 maxTokens:      maxTokens,
//                 refillInterval: refillInterval,
//         }
//         go func() {
//                 ticker := time.NewTicker(refillInterval)
//                 for range ticker.C {
//                         rl.mu.Lock()
//                         if rl.tokens &lt; rl.maxTokens {
//                                 rl.tokens++
//                         }
//                         rl.mu.Unlock()
//                 }
//         }()
//         return rl
// }

// func (rl *RateLimiter) Allow() bool {
//         rl.mu.Lock()
//         defer rl.mu.Unlock()
//         if rl.tokens &gt; 0 {
//                 rl.tokens--
//                 return true
//         }
//         return false
// }

// func JSON(w http.ResponseWriter, status int, data interface{}) {
//         w.Header().Set("Content-Type", "application/json")
//         w.WriteHeader(status)
//         if data != nil {
//                 json.NewEncoder(w).Encode(data)
//         }
// }

// func String(w http.ResponseWriter, status int, data string) {
//         w.Header().Set("Content-Type", "text/plain")
//         w.WriteHeader(status)
//         w.Write([]byte(data))
// }

// func GetQueryParams(r *http.Request) map[string]string {
//         params := make(map[string]string)
//         query := r.URL.Query()
//         for key, val := range query {
//                 params[key] = val[0]
//         }
//         return params
// }

// func GetPathParams(r *http.Request) map[string]string {
//         ctx := r.Context()
//         var paramsKey contextKey = "params"
//         if params, ok := ctx.Value(paramsKey).(map[string]string); ok {
//                 return params
//         }
//         return nil
// }

// Package router provides a high-performance HTTP router with support for middleware,
// dynamic/static routing, an optional worker pool for request processing, and rate limiting.
package router

import (
        "context"
        "encoding/json"
        "net/http"
        "strings"
        "sync"
        "time"

        "github.com/armon/go-radix"
        "go.uber.org/zap"
)

// Middleware is a function that wraps an HTTP handler.
type Middleware func(http.HandlerFunc) http.HandlerFunc

// ctxKey is an unexported type for context keys within this package.
type ctxKey string

// paramsKey is the key under which URL parameters are stored in the request context.
const paramsKey ctxKey = "params"

// route represents a registered route.
type route struct {
        method  string
        pattern string // e.g., "/users/:id"
        handler http.HandlerFunc
}

// Router is our high-performance HTTP router.
type Router struct {
        staticRoutes  *radix.Tree  // static routes stored by exact path
        dynamicRoutes []route      // routes with parameters (e.g., ":id")
        middlewares   []Middleware // middleware chain
        logger        *zap.Logger  // high-performance logger
        workerPool    *WorkerPool  // optional concurrent worker pool for handling requests
        rateLimiter   *RateLimiter // optional rate limiter on the critical path
}

// NewRouter initializes and returns a new Router.
func GjallarHorn() *Router <span class="cov8" title="1">{
        logger, err := zap.NewProduction()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">return &amp;Router{
                staticRoutes:  radix.New(),
                dynamicRoutes: make([]route, 0),
                middlewares:   []Middleware{},
                logger:        logger,
        }</span>
}

// Use adds a middleware to the chain.
func (r *Router) Use(m Middleware) *Router <span class="cov8" title="1">{
        r.middlewares = append(r.middlewares, m)
        return r
}</span>

// WithWorkerPool configures the router to use a worker pool with the specified number of workers.
func (r *Router) WithWorkerPool(poolSize int) *Router <span class="cov8" title="1">{
        r.workerPool = NewWorkerPool(poolSize)
        return r
}</span>

// WithRateLimiter configures the router to use a rate limiter.
func (r *Router) WithRateLimiter(maxTokens int, refillInterval time.Duration) *Router <span class="cov8" title="1">{
        r.rateLimiter = NewRateLimiter(maxTokens, refillInterval)
        return r
}</span>

// Handle registers a new route with the given HTTP method, pattern, and handler.
// Static routes (without parameters) are stored in the radix tree for fast lookup.
func (r *Router) Handle(method, pattern string, handler http.HandlerFunc) *Router <span class="cov8" title="1">{
        rt := route{
                method:  method,
                pattern: pattern,
                handler: handler,
        }
        if !strings.ContainsAny(pattern, ":*") </span><span class="cov8" title="1">{
                r.staticRoutes.Insert(pattern, rt)
        }</span> else<span class="cov8" title="1"> {
                r.dynamicRoutes = append(r.dynamicRoutes, rt)
        }</span>
        <span class="cov8" title="1">return r</span>
}

// GET registers a route for HTTP GET requests.
func (r *Router) GET(pattern string, handler http.HandlerFunc) *Router <span class="cov8" title="1">{
        return r.Handle(http.MethodGet, pattern, handler)
}</span>

// POST registers a route for HTTP POST requests.
func (r *Router) POST(pattern string, handler http.HandlerFunc) *Router <span class="cov8" title="1">{
        return r.Handle(http.MethodPost, pattern, handler)
}</span>

// PUT registers a route for HTTP PUT requests.
func (r *Router) PUT(pattern string, handler http.HandlerFunc) *Router <span class="cov0" title="0">{
        return r.Handle(http.MethodPut, pattern, handler)
}</span>

// DELETE registers a route for HTTP DELETE requests.
func (r *Router) DELETE(pattern string, handler http.HandlerFunc) *Router <span class="cov0" title="0">{
        return r.Handle(http.MethodDelete, pattern, handler)
}</span>

// ServeHTTP implements http.Handler. It matches incoming requests to registered routes,
// applies middleware, rate limiting, and optional worker pooling.
func (r *Router) ServeHTTP(w http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        start := time.Now()
        r.logger.Info("Incoming request",
                zap.String("method", req.Method),
                zap.String("url", req.URL.Path))

        // Attempt static (exact) route lookup.
        if val, found := r.staticRoutes.Get(req.URL.Path); found </span><span class="cov8" title="1">{
                rt := val.(route)
                if rt.method == req.Method </span><span class="cov8" title="1">{
                        r.executeHandler(w, req, rt.handler)
                        r.logger.Info("Served static route", zap.Duration("duration", time.Since(start)))
                        return
                }</span>
                <span class="cov0" title="0">w.Header().Set("Allow", rt.method)
                http.Error(w, "405 method not allowed", http.StatusMethodNotAllowed)
                r.logger.Info("Method not allowed (static)", zap.Duration("duration", time.Since(start)))
                return</span>
        }

        // Fallback: iterate over dynamic routes.
        <span class="cov8" title="1">for _, rt := range r.dynamicRoutes </span><span class="cov8" title="1">{
                if params, ok := matchPattern(rt.pattern, req.URL.Path); ok &amp;&amp; rt.method == req.Method </span><span class="cov8" title="1">{
                        ctx := context.WithValue(req.Context(), paramsKey, params)
                        r.executeHandler(w, req.WithContext(ctx), rt.handler)
                        r.logger.Info("Served dynamic route", zap.Duration("duration", time.Since(start)))
                        return
                }</span>
        }

        <span class="cov0" title="0">http.NotFound(w, req)
        r.logger.Info("Route not found", zap.Duration("duration", time.Since(start)))</span>
}

// executeHandler builds the middleware chain, applies rate limiting,
// and dispatches the request either directly or via the worker pool.
// If a worker pool is used, it waits for the handler to finish before returning.
func (r *Router) executeHandler(w http.ResponseWriter, req *http.Request, handler http.HandlerFunc) <span class="cov8" title="1">{
        // Build the final handler by wrapping with middleware.
        finalHandler := handler
        for i := len(r.middlewares) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                finalHandler = r.middlewares[i](finalHandler)
        }</span>

        // Check rate limiting.
        <span class="cov8" title="1">if r.rateLimiter != nil &amp;&amp; !r.rateLimiter.Allow() </span><span class="cov8" title="1">{
                http.Error(w, "429 Too Many Requests", http.StatusTooManyRequests)
                return
        }</span>

        // If using the worker pool, wait for the handler to complete before returning.
        <span class="cov8" title="1">if r.workerPool != nil </span><span class="cov8" title="1">{
                var done sync.WaitGroup
                done.Add(1)
                r.workerPool.Submit(func() </span><span class="cov8" title="1">{
                        finalHandler(w, req)
                        done.Done()
                }</span>)
                <span class="cov8" title="1">done.Wait()</span>
        } else<span class="cov8" title="1"> {
                finalHandler(w, req)
        }</span>
}

// Start launches the HTTP server on the specified port with defined timeouts.
func (r *Router) Start(port string) error <span class="cov0" title="0">{
        server := &amp;http.Server{
                Addr:         ":" + port,
                Handler:      r,
                IdleTimeout:  90 * time.Second,
                ReadTimeout:  10 * time.Second,
                WriteTimeout: 10 * time.Second,
        }
        r.logger.Info("Starting server on port " + port)
        return server.ListenAndServe()
}</span>

// matchPattern compares a route pattern (e.g., "/user/:id") with a request path.
// It extracts parameters and returns them if the path matches the pattern.
func matchPattern(pattern, path string) (map[string]string, bool) <span class="cov8" title="1">{
        patternParts := splitPath(pattern)
        pathParts := splitPath(path)
        if len(patternParts) != len(pathParts) </span><span class="cov0" title="0">{
                return nil, false
        }</span>
        <span class="cov8" title="1">params := make(map[string]string)
        for i, part := range patternParts </span><span class="cov8" title="1">{
                if len(part) &gt; 0 &amp;&amp; part[0] == ':' </span><span class="cov8" title="1">{
                        // Dynamic segment: capture parameter.
                        key := part[1:]
                        params[key] = pathParts[i]
                }</span> else<span class="cov8" title="1"> if part != pathParts[i] </span><span class="cov0" title="0">{
                        return nil, false
                }</span>
        }
        <span class="cov8" title="1">return params, true</span>
}

// splitPath splits a URL path into segments, ignoring empty segments.
func splitPath(path string) []string <span class="cov8" title="1">{
        return strings.FieldsFunc(path, func(r rune) bool </span><span class="cov8" title="1">{ return r == '/' }</span>)
}

// WorkerPool manages a pool of worker goroutines to execute tasks concurrently.
type WorkerPool struct {
        tasks chan func()
        wg    sync.WaitGroup
}

// NewWorkerPool creates a new WorkerPool with the specified number of workers.
func NewWorkerPool(size int) *WorkerPool <span class="cov8" title="1">{
        wp := &amp;WorkerPool{
                tasks: make(chan func(), size),
        }
        for i := 0; i &lt; size; i++ </span><span class="cov8" title="1">{
                go wp.worker()
        }</span>
        <span class="cov8" title="1">return wp</span>
}

// worker is the function run by each worker goroutine.
func (wp *WorkerPool) worker() <span class="cov8" title="1">{
        for task := range wp.tasks </span><span class="cov8" title="1">{
                task()
                wp.wg.Done()
        }</span>
}

// Submit enqueues a task to be executed by the worker pool.
func (wp *WorkerPool) Submit(task func()) <span class="cov8" title="1">{
        wp.wg.Add(1)
        wp.tasks &lt;- task
}</span>

// Shutdown gracefully shuts down the worker pool by waiting for all tasks to complete
// and then closing the task channel.
func (wp *WorkerPool) Shutdown() <span class="cov0" title="0">{
        wp.wg.Wait()
        close(wp.tasks)
}</span>

// RateLimiter implements a simple token bucket rate limiter.
type RateLimiter struct {
        tokens         int
        maxTokens      int
        mu             sync.Mutex
        refillInterval time.Duration
        quit           chan struct{}
}

// NewRateLimiter creates a new RateLimiter with the specified maximum tokens and refill interval.
func NewRateLimiter(maxTokens int, refillInterval time.Duration) *RateLimiter <span class="cov8" title="1">{
        rl := &amp;RateLimiter{
                tokens:         maxTokens,
                maxTokens:      maxTokens,
                refillInterval: refillInterval,
                quit:           make(chan struct{}),
        }
        go rl.refillTokens()
        return rl
}</span>

// refillTokens periodically refills tokens up to the maximum allowed.
func (rl *RateLimiter) refillTokens() <span class="cov8" title="1">{
        ticker := time.NewTicker(rl.refillInterval)
        defer ticker.Stop()
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ticker.C:<span class="cov8" title="1">
                        rl.mu.Lock()
                        if rl.tokens &lt; rl.maxTokens </span><span class="cov8" title="1">{
                                rl.tokens++
                        }</span>
                        <span class="cov8" title="1">rl.mu.Unlock()</span>
                case &lt;-rl.quit:<span class="cov0" title="0">
                        return</span>
                }
        }
}

// Allow checks if a request is allowed under the current rate limit.
// It returns true and decrements a token if available.
func (rl *RateLimiter) Allow() bool <span class="cov8" title="1">{
        rl.mu.Lock()
        defer rl.mu.Unlock()
        if rl.tokens &gt; 0 </span><span class="cov8" title="1">{
                rl.tokens--
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

// Stop stops the token refill goroutine.
func (rl *RateLimiter) Stop() <span class="cov0" title="0">{
        close(rl.quit)
}</span>

// JSON writes a JSON response with the specified status code.
func JSON(w http.ResponseWriter, status int, data interface{}) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(status)
        if data != nil </span><span class="cov8" title="1">{
                _ = json.NewEncoder(w).Encode(data)
        }</span>
}

// String writes a plain text response with the specified status code.
func String(w http.ResponseWriter, status int, data string) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "text/plain")
        w.WriteHeader(status)
        w.Write([]byte(data))
}</span>

// GetQueryParams extracts query parameters from the request URL.
func GetQueryParams(req *http.Request) map[string]string <span class="cov8" title="1">{
        params := make(map[string]string)
        for key, vals := range req.URL.Query() </span><span class="cov8" title="1">{
                if len(vals) &gt; 0 </span><span class="cov8" title="1">{
                        params[key] = vals[0]
                }</span>
        }
        <span class="cov8" title="1">return params</span>
}

// GetPathParams retrieves dynamic path parameters from the request context.
func GetPathParams(req *http.Request) map[string]string <span class="cov8" title="1">{
        if params, ok := req.Context().Value(paramsKey).(map[string]string); ok </span><span class="cov8" title="1">{
                return params
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
